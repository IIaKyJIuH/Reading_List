# Коротко

Мини‑сервис для ведения списка материалов (книги / статьи) с тегами, статусами и приоритетами.

Стек:

* Python 3.13
* FastAPI
* SQLAlchemy 2.0 (ORM)
* Pydantic v2
* sqlite3 (по умолчанию)
* uv (менеджер пакетов)
* ruff (линтер / форматтер)

Аутентификация реализована в виде псевдо‑auth через HTTP‑заголовок `X-User-Id`.

---

## 1. Требования

* Python **3.13**
* Установленный `uv`

Проверка:

```bash
python3.13 --version
uv --version
```

---

## 2. Установка зависимостей

```bash
uv sync --all-groups
```

---

## 3. Переменные окружения

```env
DATABASE_URL=sqlite:///app.db
```

---

## 4. Инициализация базы данных

Таблицы создаются автоматически при старте сервера.

Запуск сервера:

```bash
uv run uvicorn app.main:app --reload
```

---

## 5. Заполнение seed-данных

В проекте есть файл:

```text
seed.py
```

Запуск:

```bash
uv run python seed.py
```

Будет создано:

* 2 пользователя
* 3 тэга
* 5 Item'ов с разными статусами и приоритетами

---

## 6. Псевдо-аутентификация

Во всех запросах ОБЯЗАТЕЛЬНО указывать заголовок:

```http
X-User-Id: <число>
```

Если заголовка нет → `422`
Если пользователя не существует → `401`

---

## 7. Основные эндпоинты

Запустить сервер и перейти на "<адрес создания>/docs"

### Создание Item

```http
POST /items
X-User-Id: 1
Content-Type: application/json
```

```json
{
  "title": "Clean Code",
  "kind": "book",
  "status": "planned",
  "priority": "high",
  "notes": "Must read",
  "tag_ids": [1, 2]
}
```

Указывать теги есть смысл, когда они были созданы пользователем ранее.

Можно создавать **без тегов** и `notes`:

```json
{
  "title": "Domain Driven Design",
  "kind": "book",
  "status": "planned",
  "priority": "normal"
}
```

---

### Список Item с фильтрами

```http
GET /items?status=planned&kind=book&limit=10&offset=0
X-User-Id: 1
```

Поддерживаются фильтры:

* `status`
* `kind`
* `priority`
* `title` (по подстроке)
* `tag_ids` (любой из)
* `date_from`, `date_to` (в диапазоне дат)
* `limit`, `offset`

Сортировка:

* `order_by=created_at | updated_at | priority`
* `order_by_asc=true | false`

---

### Получение Item по id

```http
GET /items/1
X-User-Id: 1
```

---

### Обновление Item

```http
PUT /items/1
X-User-Id: 1
```

```json
{
  "status": "done",
  "priority": "low",
  "tag_ids": [3]
}
```

Особая логика тегов:

* `tag_ids` отсутствует → теги не меняются
* `tag_ids: []` → теги очищаются
* `tag_ids: [1,2]` → теги перезаписываются

---

### Удаление Item

```http
DELETE /items/1
X-User-Id: 1
```

---

## 8. Управление тегами

### Создание тега

```http
POST /tags
X-User-Id: 1
```

```json
{
  "name": "backend"
}
```

!!! Имя тега НЕ уникально в рамках пользователя, не получилось реализовать.

---

### Список тегов

```http
GET /tags
X-User-Id: 1
```

---

### Обновление тега

```http
PATCH /tags
X-User-Id: 1
```

```json
{
  "id": 1,
  "name": "new-name"
}
```

---

## 9. Проверка качества кода

```bash
ruff check .
ruff format .
```

---

## 10. Архитектура проекта (основное)

```text
app/
├ ├── main.py        # Точка входа FastAPI
├ ├── config.py      # Настройки
├ ├── db.py          # Engine + Session
├ ├── models/        # ORM-модели
├ ├── schemas/       # Pydantic-схемы
├ ├── crud.py        # Логика БД
├ ├── routers/       # HTTP-роуты
├ ├── …
├ └── enums.py       # Енумы состояний
├── …
├── .env             # Настройки окружения
└── seed.py          # Файл для сидирования БД
```

---

## 11. Особенности

* аутентификацию можно улучшить до JWT, если заапгрейдить метод `app/routers/auth.py::get_user_id`
* Разделены схемы и модели
* Логика преобразования `list[int] → list[Tag]` живёт в CRUD
* SQLAlchemy используется в стиле 2.0
* Нет глобальных сессий

---

## 12. Допущения и упрощения

* Нет настоящей аутентификации (легко дорабатывается)
* Нет Alembic-миграций
* sqlite3 используется для простоты локального запуска
* Нет асинхронности (не вижу проблем для перехода при необходимости)
* Нет автоматических тестов, которые проверяют всё API (чтобы удобнее было зачекать функционал и проверить, что ничего не сломалось)
* Максимальное количество эндпоинтов реализовано для `Items`, но не для тегов с пользователями, хотя суть аналогичная и, кажется, это всё об одном и том же.

---

## 13. Быстрый старт

```bash
uv sync
uv run uvicorn app.main:app --reload
uv run python seed.py
```

После этого можно работать с API по эндпоинту "`<урл запущенного сервера>`/docs".
