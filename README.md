# Коротко

Мини‑сервис для ведения списка материалов (книги / статьи) с тегами, статусами и приоритетами.

Стек:

* Python 3.13
* FastAPI
* SQLAlchemy 2.x (ORM)
* Pydantic v2
* sqlite3 (по умолчанию)
* uv (менеджер пакетов)
* ruff (линтер / форматтер)
* ty (type checker)

Аутентификация реализована в виде псевдо‑auth через HTTP‑заголовок `X-User-Id`.

---

## 1. Требования

* Python **3.x**
* Установленный `uv` (я установил себе через `brew install uv`)

Проверка:

```bash
python --version
uv --version
```

---

## 2. Установка зависимостей

```bash
uv sync --all-groups
```

---

## 3. Переменные окружения

Чтобы просто затестить как оно работает, можно оставить такие настройки:

```env
DATABASE_URL=sqlite:///app.db
```

---

## 4. Инициализация базы данных

Таблицы создаются автоматически при старте сервера.

Запуск сервера:

```bash
uv run uvicorn app.main:app --reload
```

---

## 5. Заполнение seed-данных

В проекте есть файл, который наполняет изначально БД, **!!ПРЕДВАРИТЕЛЬНО ОЧИЩАЯ ЕЁ!!**:

Запускается так из корня проекта:

```bash
uv run python seed.py
```

Будет создано:

* 2 пользователя
* 3 тега
* 5 Item'ов с разными статусами и приоритетами

---

## 6. Псевдо-аутентификация

Во всех запросах ОБЯЗАТЕЛЬНО указывать заголовок:

```http
X-User-Id: <число>
```

Если заголовка нет -> `422`
Если пользователя не существует -> `401`
Если операции удаления, изменения пользователя и нет прав на такие действия (либо просто нет нужных полномочий, либо действия предпринимает не сам пользователь) -> `403`

---

## 7. Быстрый старт

В одном окне терминала выполнить (для запуска сервера):

```bash
uv sync
uv run uvicorn app.main:app --reload
```

После этого в другом окне выполнить (для сидирования):

```bash
uv run python seed.py
```

После этого можно играться с API по эндпоинту `http://localhost:8000/docs`, всё должно быть интуитивно понятно.

## 8. Основные эндпоинты

### Создание User

```http
POST /users
Content-Type: application/json
```

```json
{
	"email": "string",
	"display_name": "string"
}
```

---

### Получение информации по User

```http
GET /users/1
X-User-Id: 1
```

---

### Обновление User

Важно "иметь права" на такую операцию (выше).

```http
PATCH /users/1
X-User-Id: 1
```

```json
{
	"email": "new-string",
	"display_name": "new-string"
}
```

---

### Удаление User

Важно "иметь права" на такую операцию (выше).

```http
DELETE /users/1
X-User-Id: 1
```

---

### Создание Item

```http
POST /items
X-User-Id: 1
Content-Type: application/json
```

```json
{
	"title": "Clean Code",
	"kind": "book",
	"status": "planned",
	"priority": "high",
	"notes": "Must read",
	"tag_ids": [1, 2]
}
```

Указывать теги есть смысл, когда они были созданы пользователем ранее.

Можно создавать **без тегов** и `notes`, но если последний указывается, то должен быть непустой:

```json
{
  "title": "Domain Driven Design",
  "kind": "book",
  "status": "planned",
  "priority": "normal"
}
```

---

### Список Item с фильтрами

```http
GET /items?status=planned&kind=book&limit=10&offset=0
X-User-Id: 1
```

Поддерживаются фильтры:

* `status`
* `kind`
* `priority`
* `title` (по подстроке)
* `tag_ids` (любой из)
* `date_from`, `date_to` (в диапазоне дат)

Пагинация:
* `limit`, `offset`

Сортировка:

* `order_by=created_at | updated_at | priority`
* `order_by_asc=true | false`

---

### Получение Item по id

```http
GET /items/1
X-User-Id: 1
```

---

### Обновление Item

```http
PUT /items/1
X-User-Id: 1
```

```json
{
  "status": "done",
  "priority": "low",
  "tag_ids": [3]
}
```

Особая логика тегов (можно как отдельным эндпоинтом, так и вкупе с обновлением Item'а целиком):

* `tag_ids` отсутствует -> теги не меняются
* `tag_ids: []` -> теги очищаются
* `tag_ids: [1, 2]` -> теги перезаписываются

---

### Удаление Item

```http
DELETE /items/1
X-User-Id: 1
```

---

## 8. Управление тегами

### Создание тега

```http
POST /tags
X-User-Id: 1
```

```json
{
  "name": "backend"
}
```

---

### Список тегов

```http
GET /tags
X-User-Id: 1
```

---

### Обновление тега

```http
PATCH /tags/1
X-User-Id: 1
```

```json
{
  "id": 1,
  "name": "new-name"
}
```

---

### Удаление тега

```http
DELETE /tags/1
X-User-Id: 1
```

---

## 9. Линтинг/форматтирование кода

```bash
ruff check .
ruff format .
```

---

## 10. Архитектура проекта (основное)

```text
app/
├ ├── main.py        # Точка входа FastAPI
├ ├── config.py      # Настройки
├ ├── db.py          # Engine + Session
├ ├── models/        # ORM-модели
├ ├── schemas/       # Pydantic-схемы
├ ├── crud/          # Логика БД
├ ├── routers/       # HTTP-роуты
├ ├── …
├ └── enums.py       # Енумы состояний
├── …
├── .env             # Настройки окружения
└── seed.py          # Файл для сидирования БД
```

---

## 11. Особенности

* аутентификацию можно улучшить до JWT, если заапгрейдить метод `app/routers/auth.py::get_user_id`
* Разделены схемы и модели
* Логика преобразования `list[int] -> list[Tag]` живёт в CRUD
* Нет глобальных сессий

---

## 12. Допущения и упрощения

* Нет настоящей аутентификации (легко дорабатывается)
* Нет Alembic-миграций
* sqlite3 используется для простоты локального запуска
* Нет асинхронности (не вижу проблем для перехода при необходимости)
* Нет автоматических тестов, которые проверяют всё API (чтобы удобнее было зачекать функционал и проверить, что ничего не сломалось)

---
